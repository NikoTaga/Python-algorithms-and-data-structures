'''
Подсчитать, сколько было выделено памяти под переменные в ранее разработанных
программах в рамках первых трех уроков. Проанализировать результат и определить
программы с наиболее эффективным использованием памяти.

как обычно, разбор задания не смортел!

Для примера:
Урок 2. Задание 2
Посчитать четные и нечетные цифры введенного натурального числа.
Например, если введено число 34560, в нем 3 четные
цифры (4, 6 и 0) и 2 нечетные (3 и 5).
'''

import sys
from collections import deque

'''
Комментарий. 
Вариант 1.
В алгоритме подчета используются только числа. 
Проверяем поочередно каждую цифру числа на четность и увеличиваем счетчики соответственно.
В памяти только числовые переменные.
'''
def vol_1(x):
    num_in = x    # сколько в памяти занимает параметр полностью.
    ev = 0
    odd = 0
    while x != 0:
        if x % 2 == 0:
            ev += 1
        else:
            odd += 1
        x = x // 10
    return  ev, odd, show_size(num_in, x, ev, odd)

'''
Комментарий. 
Вариант 2.
В алгоритме подчета используются кортеж и числовые переменные. 
Проверяем поочередно каждый элемент кортежа на четность и увеличиваем счетчики соответственно.
В памяти числовые переменные и кортеж.
'''
def vol_2(x):
    ev = 0
    odd = 0
    num = tuple(x)
    for i in num:
        if int(i) % 2 == 0:
            ev += 1
        else:
            odd +=1
    return ev, odd, show_size(num, i, ev, odd)

'''
Комментарий. 
Вариант 3.
В алгоритме подчета используются очередь и числовые переменные. 
Проверяем поочередно каждый элемент очереди на четность и увеличиваем счетчики соответственно.
В памяти числовые переменные и очередь.
'''
def vol_3(x):
    ev = 0
    odd = 0
    num = deque(x)
    for i in num:
        if int(i) % 2 == 0:
           ev += 1
        else:
            odd += 1
    return ev, odd, show_size(num, i, ev, odd)

def show_size(*args):
    global m_count
    for x in args:
        m_count += sys.getsizeof(x)
        # print(f'type={type(x)}, size={sys.getsizeof(x)}, obj={x}')
        if hasattr(x, '__iter__'):
            if hasattr(x, 'items'):
                for key, value in x.items():
                    show_size(key)
                    show_size(value)
            elif not isinstance(x, str):
                for item in x:
                    show_size(item)
    return m_count


a = (input('Введите натуральное число :'))

# Вариант 1
m_count = 0
b, c, d = vol_1(int(a))
print(f'Вар.1: четных {b}, нечетных {c}, Занятая память {d}')

# Вариант 2
m_count = 0
b, c, d = vol_2(a)
print(f'Вар.2: четных {b}, нечетных {c}, Занятая память {d}')

# Вариант 3
m_count = 0
b, c, d = vol_3(a)
print(f'Вар.3: четных {b}, нечетных {c}, Занятая память {d}')

'''
indows 10 Домашняя 
версия 1809
тип 64-разрядная операционная система, процессор x64

Python 3.7 - 32 bit

Вывод:
Из трех вариантов лучший - 1-ый.
Т.к. в алгоритме не используются сложные структуры, а используются 
числовые переменные, которым занимают намного меньше памяти чем кортеж и очередь.
'''
